# Grade 1. Этап 3: Задание 2
# Задание: Функция обновления заметки


from datetime import datetime, timedelta       # Вызов библиотеки datetime


# Функция создания заметки, входное значение "количество заметок"
def make_dict(id_note):
    all_dict = {'ID:': '',                  # Поля для заполнения пользователем
                'Имя:': '',
                'Заголовок:': '',
                'Описание:': '',
                'Статус:': '',
                'Дата создания:': '',
                'Дедлайн:': ''}

    for i in all_dict.keys():                       # Запрос пользовательских данных по имеющимся полям
        if i == 'ID:':                              # Установка ID заметки
            all_dict['ID:'] = id_note
            continue
        if i == 'Дата создания:':                   # Запрос даты создания заметки с использованием функции проверки даты
            # Функция проверки даты с определенным агрументом
            all_dict['Дата создания:'] = check_user_date('создания')
        elif i == 'Дедлайн:':                       # Запрос даты дедлайна заметки с использованием функции проверки даты
            # Функция проверки даты с определенным агрументом
            all_dict['Дедлайн:'] = check_user_date('дедлайна')
        elif i == 'Статус:':                        # Запрос статуса с предложениями ввода
            # Функция проверки введенного статуса
            all_dict['Статус:'] = status_note()

        else:
            # Ввод пользовательских значений
            all_dict[i] = input(f'Введите {i} ')
            # Значения по умолчанию для пустого заголовка
            if all_dict['Заголовок:'] == '':
                all_dict['Заголовок:'] = 'Пустой заголовок'
            # Значения по умолчанию для пустого описания
            elif all_dict['Описание:'] == '':
                all_dict['Описание:'] = 'Без описания'
    return (all_dict)                     # Возврат готового словаря


def status_note():          # Функция проверки ввода статуса
    status = input(
        f'Введите статус заметки (Новая, В процессе, Выполнено): ').capitalize()
    # Проверка статуса на соответствие предложенным вариантам
    while status not in ('Новая', 'В процессе', 'Выполнено'):
        status = input(
            f'Выберите один из предложенных вариантов (Новая, В процессе, Выполнено): ').capitalize()
    return (status)


# Функция проверки правильного формата даты, входное значение "создание" или "дедлайн"
def check_user_date(user_date):
    while True:
        # Запрос пользовательской даты
        issue_date = input(
            f'Введите дату {user_date} (день-месяц-год или нажмите ENTER для автоматичекой установки): ')
        # Установка сегодняшней даты, если пользователь ничего не ввел
        if issue_date == '' and user_date == 'создания':
            # Запрос сегодняшней даты
            today = datetime.today().date()
            issue_date = today.strftime('%d-%m-%Y')
        elif issue_date == '' and user_date == 'дедлайна':
            # Установка даты дедлайна на неделю позже сегодняшнего числа
            today = datetime.today().date() + timedelta(days=7)
            issue_date = today.strftime('%d-%m-%Y')
        try:
            # проверка на формат дд-мм-ГГГГ
            value_date = datetime.strptime(issue_date, '%d-%m-%Y').date()
            break
        except ValueError:              # Игнорирование ошибки о неправильном значении даты
            try:
                # Проверка введеной даты на формат ГГГГ-мм-дд
                value_date = datetime.strptime(
                    issue_date, '%Y-%m-%d').date()
                # Перевод даты в формат дд-мм-ГГГГ
                issue_date = value_date.strftime('%d-%m-%Y')
                break
            except ValueError:                      # Игнорирование ошибки о неправильном значении даты
                print('')
                # Вывод сообщения для пользователя о недопустимом формате даты
                print(
                    'Убедитесь, что вводите дату в формате день-месяц-год или нажмите ENTER для автоматичекой установки')
                print('')
                continue                            # Переход к началу цикла о запросе даты
    # Возврат значения даты в соответствующую переменную
    return (issue_date)


# Функция подтверждения изменения или удаления заметки
def conf_change(do_note):
    conf_del_note = 'V'             # Временная переменная для запуска цикла
    if do_note == 'удалить':         # Корректное отображение обращения к пользователю
        do_note_01 = 'удалена'
    elif do_note == 'изменить':
        do_note_01 = 'изменена'

    while conf_del_note != 'Нет':       # Цикл на подтверждение изменения
        # Запрос Да/Нет не зависит от регистра
        conf_del_note = input(
            f'Вы уверены что хотите {do_note} заметку? Да/Нет - ').capitalize()
        if conf_del_note == 'Да':                   # Подтверждение введеных изменений
            print(f'Заметка успешно {do_note_01}.')
            break
        elif conf_del_note == 'Нет':                # Отмена введеных изменений
            print('Действие отменено.')
            break
        else:
            print('Команда не распознана.')
    # Возврат пользовательского ответа (да/нет)
    return (conf_del_note)


# Функция редактирования полей заметки
def upd_note(upd_dict):
    pole = input('Какое поле вы хотите отредактировать: ').capitalize()
    pole = pole + ':'
    if pole in ('Id:', 'Дата создания:'):               # эти поля не должны редактироватся
        print('Данное поле нельзя отредактировать.')
    elif pole == 'Статус:':
        # Переход в функцию проверки статуса
        upd_dict[pole] = status_note()
    elif pole == 'Дедлайн:':
        # Переход в функцию проверки введенной даты
        upd_dict[pole] = check_user_date('дедлайна')
    elif pole in upd_dict.keys():
        upd_dict[pole] = input('Введите новое значение поля: ')
    else:
        print('Такого поля не обнаружено.')
    return (upd_dict)                   # Возвращение отредактированной заметки


list_notes = []     # Создание списка
count_note = 1000   # Счетчик заметок и их ID
choose_do = ['1 - Добавить заметку.',               # Меню доступных для пользователя действий
             '2 - Просмотреть все заметки.',        # У пользователя запрашивается номер пункта
             '3 - Редактировать заметку.',
             '4 - Удалить заметку.',
             '5 - Выход'
             ]

print('\nДобро пожаловать в "Менеджер заметок"!\n')

# Условие работы цикла по созданию заметок, выполняется пока пользоваатель не выберет 'Выход'
making_note = True

while making_note:
    print()
    print('\n'.join(choose_do))             # Вывод пользовательского меню
    # Ввод ответа не зависит от регистра
    add_note = input(
        'Что вы хотите сделать? (Введите номер): ')

    if add_note == '1':
        # Команда 'Добавить заметку.'
        count_note += 1
        print('\nСоздание новой заметки.')
        # Добавление полученных данных в основной словарь через функцию make_dict
        list_notes.append(make_dict(str(count_note)))

    elif add_note == '2':
        # Команда на просмотр всех заметок
        if list_notes == []:
            print('\nВы не создали ни одной заметки.')
        else:
            print(f'\nУ вас {len(list_notes)} заметок')
            print('Вот текущий список ваших заметок:\n')
            # Вывод на экран списка каждый элемент которого является отдельной заметкой
            for i in range(len(list_notes)):
                # Вывод каждой заметки в виде словаря
                for keys_00, value_00 in list_notes[i].items():
                    print(keys_00, value_00)
                print('')

    elif add_note == '3':       # Редактирование заметки
        next_pole = 'V'
        del_note = {}           # Временный словарь для хранения заметки для редактирования
        count_del = 0           # Счетчик совпадений
        choose_note = input(
            'Введите ID или имя пользователя или заголовок для редактирования заметки: ').capitalize()
        for i in range(len(list_notes)):
            for keys_00, value_00 in list_notes[i].items():
                if value_00 == choose_note:         # Поиск совпадений
                    del_note = list_notes[i]        # Выбор нужной заметки
                    num = i                         # Номер выбранной заметки в списке словарей
                    count_del += 1                  # Количество заметок с одинаковым идентификатором
            print('')
        if count_del > 1:                           # Обнаружено больше одной заметки
            print(
                f'Выявлено больше одного совпадения по метке {num_del}, введите другой идентификатор.')
        elif count_del == 0:                        # Заметок с таким запросом не обнаружено
            print('Заметок с таким ID или именем пользователя или заголовком не найдено.')
        else:
         #   temp_dict = del_note.copy()  # Создание копии на случай отмены редактирования

            # Цикл на изменение более одного поля в заметке, работает до ответа пользователя 'Нет'
            while next_pole != 'Нет':                   
                temp_dict = del_note.copy()  # Создание копии на случай отмены редактирования
                # Запуск функции редактирования заметки
                list_notes[num] = upd_note(del_note)
                # Запуск функции подтверждения изменения
                conf_del_note = conf_change('изменить')
                if conf_del_note == 'Нет':
                    # Восстановление заметки при отмене изменений
                    list_notes[num] = temp_dict
                next_pole = input('Хотите отредактировать еще одно поле? Да/Нет ').capitalize()

    elif add_note == '4':           # Удаление заметки
        del_note = {}               # Временный словарь для хранение заметки на удаление
        count_del = 0               # Счетчик совпадений
        # Запрос по какому ID или имени или заголовку произвести удаление заметки
        num_del = input(
            'Введите ID или имя пользователя или заголовок для удаления заметки: ').capitalize()
        for i in range(len(list_notes)):
            for keys_00, value_00 in list_notes[i].items():
                if value_00 == num_del:         # Поиск совпадений
                    del_note = list_notes[i]    # Выбор нужной заметки
                    count_del += 1              # Количество заметок с одинаковым идентификатором
            print('')
        if count_del > 1:                       # Обнаружено больше одной заметки
            print(
                f'Выявлено больше одного совпадения по метке {num_del}, введите другой идентификатор.')
        elif count_del == 0:                    # Заметок с таким запросом не обнаружено
            print('Заметок с таким ID или именем пользователя или заголовком не найдено.')
        else:
            # Запуск функции подтверждения удаления
            conf_del_note = conf_change('удалить')
            if conf_del_note == 'Да':
                list_notes.remove(del_note)             # Удаление заметки
            if conf_del_note == 'Нет':
                print('Удаление отменено.')

    elif add_note == '5':
        # Команда 'Выход' Прерывание цикла
        print('\nУдачного дня.\n')
        making_note = False
    else:
        print('\nНекорректный ответ')
